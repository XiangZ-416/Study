# Java多线程基础

## 一、什么是进程、线程？
    进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
    线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。

## 二、线程与进程的区别
    1.包含关系：一个程序至少有一个进程,一个进程至少有一个线程.
    2.划分尺度：线程的划分尺度小于进程，使得多线程程序的并发性高。
    3.执行过程：进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
    4.操作系统的角度：操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。  
    
    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程
    产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于
    整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且
    又要共享某些变量的并发操作，只能用线程，不能用进程  
    
## 三、创建并启动线程
~~~ java
    // 将数据库读写改为多线程
    new Thread("READ-Thread") {
        @Override
        public void run() {
            readFromDataBse();
        }
    }.start();
    
    new Thread("WRITE-Thread") {
        @Override
        public void run() {
            writeDataToFile();
        }
    }.start();
~~~ 
    不能启动一个线程两次。
    1.为什么调用start()方法，而不直接调用run()方法？
        调用run()方法只会启动main线程，不会启动自己定义的线程。
    2.调用start()方法如何与重写的run()方法关联？
        调用start()方法后，Thread类中会判断线程状态，进而调用Thread中的start0()方法，start0()会将当前线程加入同步队列，然
        后调用重写的run()方法。
    3.这样做的好处：

## 四、线程的生命周期
![线程生命周期](../imgs/01.png) 

## 五、总结
    1.Java应用程序的main函数是一个线程，是被JVM启动的时候调用，线程的名字叫main
    2.实现一个线程，必须创建Thread实例，override run方法，并且调用start方法
    3.在JVM启动后，实际上有多个线程，但只必须有一个非守护线程
    4.守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
        因此，JVM退出时，不必关心守护线程是否已结束。
        如何创建守护线程呢？方法和普通线程一样，只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程：
        Thread t = new MyThread();
        t.setDaemon(true);
        t.start();
        举例， GC垃圾回收线程：就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾
        回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，
        用于实时监控和管理系统中的可回收资源。
    5.当调用一个线程的start方法时，此时至少有两个线程，一个是调用你的线程，还有一个是执行run方法的线程
    6.线程的生命周期分为：new（新建）、runnable（就绪）、running（运行）、block（阻塞）、termate（死亡）
    