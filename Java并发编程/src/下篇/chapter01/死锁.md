# 死锁

## 一、产生死锁的原因
        线程A占有不可抢占的资源a还要获取其他不可抢占的资源b && 线程B占有不可抢占的资源b还有要获取其他不可抢占的资源a。

![死锁](../../imgs/02.png)        
   
## 二、死锁产生的四个必要条件
    互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
    请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
    不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
    环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。
    
## 三、如何解决死锁？
    1.尽量不要让程序出现多个锁层叠的关系
    2.超时放弃：Lock接口提供了boolean tryLock(long time, TimeUnit unit) throws InterruptedException方法
    3.以确定的顺序获得锁
    
## 四、如何找到死锁的两个线程（死锁检测）？
    cmd -> jps找到产生死锁的线程相应的进程号 -> jstack 进程号 -> 就会显示found n deadlock
    