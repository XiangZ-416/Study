## 一、装饰模式
    （1）在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。
         它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
    （2）在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则，和里氏替换原则。
***
## 二、设计原则
    要使用装饰者模式，需要满足以下设计原则：
    1、多用组合，少用继承
    2、开放-关闭原则：类应该对拓展开放，对修改关闭
***
## 三、抽象构件角色
    1) 抽象构件角色（Component）：是基类。如：人。通常是一个抽象类或者一个接口，定义了属性或者方法，方法的实现可以由子类实现或者自己实现。
        通常不会直接使用该类，而是通过继承该类来实现特定的功能，它约束了整个继承树的行为。比如说，如果Component代表人，即使通过装饰也不会
        使人变成别的动物。 
    2) 被装饰者角色(Concrete Component)：是Component的子类。如：青少年。实现了相应的方法，它充当了“被装饰者”的角色。 
    3) 装饰者角色(Decorator)：也是Component的子类。如：衣服。它是装饰者共同实现的抽象类（也可以是接口）。比如说，Decorator代表衣服这一类
        装饰者，那么它的子类应该是T恤、裙子这样的具体的装饰者。
    4) 具体装饰角色(Concrete Decorator)：是Decorator的子类。如：衬衫。是具体的装饰者，由于它同时也是Component的子类，因此它能方便地拓展
        Component的状态（比如添加新的方法）。每个装饰者都应该有一个实例变量用以保存某个Component的引用，这也是利用了组合的特性。在持有
        Component的引用后，由于其自身也是Component的子类，那么，相当于ConcreteDecorator包裹了Component，不但有Component的特性，同时自
        身也可以有别的特性，也就是所谓的装饰。
***
## 四、案例
    你有一家服装店，卖各式各样的衣服，现在需要用一个系统来记录客户所要购买的衣服的总价，以便方便地结算。那么在这个例子里面，我们可以用装饰者模
    式，把客户当做被装饰者，衣服是装饰者，这很直观形象吧，接着我们来一步步实现需求。
***
## 五、案例类图
   ![decorativeMode.png](imgs/Type_03_decorativeMode.png)
***
## 六、案例总结
    （1）Teenager、Cloth都是继承自Person基类，但是具体实现不同。
    （2）Teenager是Person的直接子类，表示了被装饰者；
    （3）Shirt是装饰者，保存了Person的引用，实现了cost()方法，并且在cost()方法内部，不但实现了自己的逻辑，同时也调用了Person引用的cost()方法，
        即获取了被装饰者的信息，这是装饰者的一个特点，保存引用的目的就是为了获取被装饰者的状态信息，以便将自身的特性加以组合。
***
## 七、装饰者模式总结
    通过上述的例子，我们可以总结一下装饰者模式的特点：
    （1）装饰者和被装饰者有相同的接口（或有相同的父类）。
    （2）装饰者保存了一个被装饰者的引用。
    （3）装饰者接受所有客户端的请求，并且这些请求最终都会返回给被装饰者（参见韦恩图）。
    （4）在运行时动态地为对象添加属性，不必改变对象的结构。
***
## 八、优缺点
    优点：就是其拓展性十分良好，通过使用不同的装饰类来使得对象具有多种多样的属性，灵活性比直接继承好。
    缺点，那就是会出现很多小类，即装饰类，使程序变得复杂。
    