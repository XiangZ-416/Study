题目分类整理

## 链表问题

### 题目1：从尾到头打印链表

#### 题目描述

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

#### 思路

```java
// 用栈
public static void printListFromHeadToTail1(ListNode head) {
    if (head == null) {
        return;
    }
    Stack<ListNode> stack = new Stack<>();
    while (head != null) {
        stack.push(head);
        head = head.next;
    }
    while (!stack.isEmpty()) {
        System.out.print(stack.pop().val + " ");
    }
}

// 不用栈
public static void printListFromHeadToTail2(ListNode head) {
    if (head == null) {
        return;
    }
    // 链表逆序
    ListNode pre = null;
    ListNode next = null;
    while (head != null) {
        next = head.next;
        head.next = pre;
        pre = head;
        head = next;
    }
    ListNode cur = pre;
    while (cur != null) {
        System.out.print(cur.val + " ");
        cur = cur.next;
    }
    // 链表逆序
    ListNode PRE = null;
    ListNode NEXT = null;
    while (pre != null) {
        NEXT = pre.next;
        pre.next = PRE;
        PRE = pre;
        pre = NEXT;
    }
}
```



### 题目2：链表中倒数第k个结点

#### 题目描述

输入一个链表，输出该链表中倒数第k个结点。

#### 思路

```java
public ListNode FindKthToTail(ListNode head,int k) {
    if(head == null || k == 0) {
        return null;
    }
    Stack<ListNode> stack = new Stack<>();
    int num = 0;
    while(head != null) {
        stack.push(head);
        num++;
        head = head.next;
    }
    if(num < k) {
        return null;
    }

    for(int i = 1; i < k; i++) {
        stack.pop();
    }
    return stack.pop();
}
```



### 题目3：反转链表

#### 题目描述

输入一个链表，反转链表后，输出新链表的表头。

#### 思路

```java
public ListNode ReverseList(ListNode head) {
    if(head == null) {
        return null;
    }
    ListNode pre = null;
    ListNode next = null;
    ListNode cur = head;
    while(cur != null) {
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```



### 题目4：合并两个排序的链表

#### 题目描述

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

#### 思路

```java
public ListNode merge(ListNode list1, ListNode list2) {
    if (list1 == null && list2 == null)
        return null;
    if (list1 == null && list2 != null)
        return list2;
    if (list1 != null && list2 == null)
        return list1;
    ListNode cur1 = list1; // 指针1
    ListNode cur2 = list2; // 指针2
    ArrayList<ListNode> list = new ArrayList<>();
    while (cur1 != null && cur2 != null) { // 谁小谁的指针向右移
        if (cur1.val <= cur2.val) {
            list.add(cur1);
            cur1 = cur1.next;
        } else {
            list.add(cur2);
            cur2 = cur2.next;
        }
    }
    while (cur1 != null) { // list1没遍历完
        list.add(cur1);
        cur1 = cur1.next;
    }
    while (cur2 != null) { // list2没遍历完
        list.add(cur2);
        cur2 = cur2.next;
    }
    ListNode newHead = list.get(0);
    ListNode cur = newHead;
    for (ListNode curNode : list) { // 将list中的节点连成链表
        cur.next = curNode;
        cur = curNode;
    }
    return newHead;
}
```



### 题目5：复杂链表的复制 

#### 题目描述

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

#### 思路

```java
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}

public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null) {
        return null;
    }
    Map<RandomListNode, RandomListNode> map = new HashMap<>();
    RandomListNode cur = pHead;
    while (cur != null) {
        map.put(cur, new RandomListNode(cur.label));
        cur = cur.next;
    }
    RandomListNode CUR = pHead;
    while (CUR != null) {
        // 注意不能写成map.get(CUR).next = CUR.next。否则新旧链表之间互连，而不是复制新的链表
        map.get(CUR).next = map.get(CUR.next); 
        map.get(CUR).random = map.get(CUR.random);
        CUR = CUR.next;
    }
    return map.get(pHead);
}
```



### 题目6：两个链表的第一个公共节点

#### 题目描述

输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

#### 思路

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    if(pHead1 == null || pHead2 == null) {
        return null;
    }
    int p1 = 0;
    ListNode curNode1 = pHead1;
    while(curNode1 != null) {
        p1++;
        curNode1 = curNode1.next;
    }
    int p2 = 0;
    ListNode curNode2 = pHead2;
    while(curNode2 != null) {
        p2++;
        curNode2 = curNode2.next;
    }
    int cha = p1 - p2;
    if(cha > 0) { // pHead1较长
        while(cha > 0) {
            pHead1 = pHead1.next;
            cha--;
        }
        while(pHead1 != null && pHead2 != null) {
            if(pHead1 == pHead2) {
                return pHead1;
            }
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
    } else { // pHead2较长
        while(cha > 0) {
            pHead2 = pHead2.next;
            cha--;
        }
        while(pHead1 != null && pHead2 != null) {
            if(pHead1 == pHead2) {
                return pHead1;
            }
            pHead1 = pHead1.next;
            pHead2 = pHead2.next;
        }
    }
    return null;
}  
```



### 题目7：圆圈中剩下的数字

#### 题目描述

每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

如果没有小朋友，请返回-1

#### 思路

```java
// 方法1：用ArrayList模拟删除过程
public int LastRemaining_Solution(int n, int m) {
    if (m == 0) {
        return -1;
    }
    ArrayList<Integer> list = new ArrayList<>(n);
    int num = 0;
    while (num < n) {
        list.add(num++);
    }
    int start = 0;
    while (n > 1) {
        start = (start + m - 1) % n;
        list.remove(start);
        n--;
    }
    return list.get(0);
}

// 方法2：从最后一轮反推
public int lastRemaining(int n, int m) {
    int ans = 0;
    // 从最后一轮（剩下两个数时）反推最终剩下的数字
    for (int i = 2; i <= n; i++) {
        ans = (ans + m) % i; // 上一轮中的位置 = （当前位置 + m） % 上一轮剩下的个数
    }
    return ans;
}
```



### 题目8：链表中环的入口节点

#### 题目描述

给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

#### 思路

```java
public ListNode EntryNodeOfLoop(ListNode pHead){
    if(pHead == null || pHead.next == null || pHead.next.next == null) return null;
    ListNode slow = pHead;
    ListNode fast = pHead;
    while(slow.next != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow.equals(fast)) {
            break;
        }
    }
    if (fast == null) {
        return null;
    }
    fast = pHead;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}
```



### 题目9：删除链表中重复的数字

#### 题目描述

牛客：1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 5 删除后 1 -> 3 -> 5

leetcode：1 -> 2 -> 2 -> 3 -> 4 -> 4 -> 5 删除后 1 -> 2 -> 3 -> 4 -> 5

#### 思路

```java
// 牛客
public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null || pHead.next == null)
        return pHead;
    // 找到删除重复节点后的链表的头节点
    ListNode ans = pHead;
    while (ans != null) {
        if (ans.next != null && ans.val == ans.next.val) {
            int val = ans.val;
            while (ans != null && ans.val == val) {
                ans = ans.next;
            }
        } else {
            break;
        }
    }
    if (ans == null) { // pHead为头的链表所有节点值都相等
        return null;
    }
    // 判断ans之后的节点是否重复，若重复，则跳过
    ListNode lastNode = ans;
    ListNode curNode = ans.next;
    while (curNode != null) {
        if (curNode.next != null && curNode.val == curNode.next.val) {
            int val = curNode.val;
            while (curNode != null && curNode.val == val) {
                curNode = curNode.next;
            }
        } else {
            lastNode.next = curNode;
            lastNode = curNode;
            curNode = curNode.next;
        }
    }
    lastNode.next = null;
    return ans;
}

// leecode
public ListNode deleteDuplicates(ListNode head) {
    if (head == null || head.next == null)
        return head;
    // 找到删除重复节点之后的新链表的头节点ans
    ListNode ans = head;
    while (ans != null) {
        if (ans.next != null && ans.val == ans.next.val) {
            ans = ans.next;
        } else {
            break; // 此时ans就是新的头节点
        }
    }
    if (ans == null) {
        return null;
    }
    // 判断ans后面的节点是否有重复的，重复就删除（跳过）
    ListNode lastNode = ans;
    ListNode curNode = ans.next;
    while (curNode != null) {
        if (curNode.next != null && curNode.val == curNode.next.val) {
            curNode = curNode.next;
        } else {
            lastNode.next = curNode;
            lastNode = curNode;
            curNode = curNode.next;
        }
    }
    lastNode.next = null;
    return ans;
}
```



## 二叉树问题

### 题目1：重建二叉树

#### 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```
例如，给出
	前序遍历 preorder = [3,9,20,15,7]
	中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
        3
       / \
      9  20
        /  \
       15   7
```

#### 思路

```java
public TreeNode recoverTree(int[] pre, int[] in) {
    if (pre == null || in == null || pre.length == 0 || in.length == 0) {
        return null;
    }

    TreeNode root = new TreeNode(pre[0]);
    int rootIndex = 0;
    for (int i = 0; i < in.length; i++) {
        if (in[i] == root.val) {
            rootIndex = i;
            break;
        }
    }
    root.left = recoverTree(Arrays.copyOfRange(pre, 1, rootIndex + 1),
                            Arrays.copyOfRange(in, 0, rootIndex));
    root.right = recoverTree(Arrays.copyOfRange(pre, rootIndex + 1, pre.length),
                             Arrays.copyOfRange(in, rootIndex + 1, in.length));

    return root;
}
```



### 题目2：树的子结构

#### 题目描述

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```
例如:
    给定的树 A:

         3
        / \
       4   5
      / \
     1   2
    给定的树 B：

       4 
      /
     1
    返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```

#### 思路

```java
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
    if (root2 == null || root1 == null) {
        return false;
    }
    return isEqual(root1, root2);
}
private boolean isEqual(TreeNode curNode, TreeNode root2) {
    boolean res = false;
    if (curNode.val == root2.val) {
        // 进入第二阶段：匹配
        res = match(curNode, root2);
    }
    if (res) { // 通过当前节点已经找到匹配的结构
        return true;
    }
    // 进入第一阶段：查找
    boolean flag1 = false;
    boolean flag2 = false;
    if (curNode.left != null) {
        flag1 = isEqual(curNode.left, root2);
    }
    if (!flag1 && curNode.right != null) {
        flag2 = isEqual(curNode.right, root2);
    }
    return flag1 || flag2; // 找到左子树、右子树其中一个等于root2的值，停止查找
}

private boolean match(TreeNode curNode1, TreeNode curNode2) {
    if (curNode2 == null) {
        return true;
    }
    if (curNode1 == null) {
        return false;
    }
    if (curNode1.val == curNode2.val) {
        boolean flag1 = true;
        boolean flag2 = true;
        if (curNode1.left != null || curNode2 != null) {
            flag1 = match(curNode1.left, curNode2.left);
        }
        if (curNode1.right !=  null || curNode2.right != null) {
            flag2 = match(curNode1.right, curNode2.right);
        }
        return flag1 && flag2;
    } else {
        return false;
    }
}
```



### 题目3：二叉树的镜像

#### 题目描述

操作给定的二叉树，将其变换为源二叉树的镜像。

```
二叉树的镜像定义：源二叉树 
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```

#### 思路

```java
public void Mirror(TreeNode root) {
    if(root == null)
        return;
    TreeNode help = root.left;
    root.left = root.right;
    root.right = help;
    Mirror(root.left);
    Mirror(root.right);
}
```



### 题目4：从上往下打印二叉树I、II、III

#### 题目1：从上往下打印二叉树I

##### 题目描述

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

```
例如:
    给定二叉树: [3,9,20,null,null,15,7],

        3
       / \
      9  20
        /  \
       15   7
返回：
    [3,9,20,15,7]
```

##### 思路

```java
public int[] levelOrder(TreeNode root) {
    if(root == null) {
        return new int[] {};
    }
    ArrayList<Integer> list = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while(!queue.isEmpty()) {
        TreeNode curNode = queue.poll();
        list.add(curNode.val);
        if(curNode.left != null) {
            queue.add(curNode.left); 
        }
        if(curNode.right != null) {
            queue.add(curNode.right);
        }
    }
    int index = 0;
    int[] res = new int[list.size()];
    for(int i = 0; i < list.size(); i++) {
        res[index++] = list.get(i);
    } 
    return res;
}
```



#### 题目2：从上往下打印二叉树II

##### 题目描述

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

```
例如:
	给定二叉树: [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
	返回其层次遍历结果：
    [
      [3],
      [9,20],
      [15,7]
    ]
```

##### 思路

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null)
        return new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int sum = 1; // 初始化当前层节点的个数
    while(!queue.isEmpty()) {
        List<Integer> list = new ArrayList<>();
        int temp = 0; // 下一层节点的个数
        while(sum > 0) {
            TreeNode curNode = queue.poll();
            list.add(curNode.val);
            if(curNode.left != null) {
                queue.add(curNode.left);
                temp++;
            }
            if(curNode.right != null) {
                queue.add(curNode.right);
                temp++;
            }
            sum--;
        }
        ans.add(list);
        sum = temp;
    }
    return ans;
}
```



#### 题目3：从上往下打印二叉树III

##### 题目描述

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

```
例如:
	给定二叉树: [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
	返回其层次遍历结果：
    [
      [3],
      [20,9],
      [15,7]
    ]
```

##### 思路

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if(root == null) return new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>(); // 最终返回的结果
    LinkedList<TreeNode> queue = new LinkedList<>(); // 层序遍历通用
    queue.add(root); // 初始化队列
    int num = 1; // 初始化当前层的节点个数
    int flag = 0; // 判断当前层是否是偶数层
    while(!queue.isEmpty()) {
        ArrayList<Integer> list = new ArrayList<>();
        int temp = 0; // 下一层的节点个数
        while(num > 0) {
            TreeNode cur = queue.poll();
            list.add(cur.val);
            if(cur.left != null) {
                queue.add(cur.left);
                temp++;
            }
            if(cur.right != null) {
                queue.add(cur.right);
                temp++;
            }
            num--; // 队列弹出一个，即当前层遍历过一个
        }
        num = temp; // 更新当前层节点个数
        flag++;
        if(flag % 2 == 0) { // 偶数层从右到左，反转list，然后将list存到ans
            for(int i = 0, j = list.size() - 1; i < j; i++, j--) {
                int help = list.get(j);
                list.set(j, list.get(i));
                list.set(i, help);
            }
        }
        ans.add(list);
    }
    return ans;
}
```



### 题目5：二叉搜索树的后序遍历序列

#### 题目描述

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

#### 思路

```java
public boolean VerifySquenceOfBST(int [] sequence) {
    if (sequence == null || sequence.length == 0) {
        return false;
    }
    ArrayList<Integer> list = new ArrayList<>();
    for (int num : sequence) {
        list.add(num);
    }
    return process(list);
}

private boolean process(ArrayList<Integer> list) {
    if (list.size() == 0 || list.size() == 1) { // 左右子树可能不存在
        return true;
    }
    ArrayList<Integer> minList = new ArrayList<>(); // 小于end的序列
    ArrayList<Integer> maxList = new ArrayList<>(); // 大于end的序列
    int end = list.get(list.size() - 1);
    int minIndex = -1, maxIndex = -1; // 第一次小于end的位置、第一次大于end的位置
    for (int i = 0; i < list.size() - 1; i++) { // 根据end划分list为大于和小于两个序列
        if (list.get(i) < end) {
            if (minIndex == -1) {
                minIndex = i;
            }
            minList.add(list.get(i));
        }
        if (list.get(i) > end) {
            if (maxIndex == -1) {
                maxIndex = i;
            }
            maxList.add(list.get(i));
        }
    }
    if (minIndex != -1 && maxIndex != -1) { // 左右两个子树都存在
        if (maxIndex < minIndex) { // 本质上是右子树上的数小
            return false;
        }
        for (int i = maxIndex; i < list.size() - 1; i++) { // 本质上是大于序列不连续，即右子树有小于根节点的数
            if (list.get(i) < end) {
                return false;
            }
        }
    }

    return process(minList) && process(maxList);
}
```



### 题目6：二叉树中和为某一值的路径

#### 题目描述

输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

#### 思路

```java
ArrayList<ArrayList<Integer>> res = null;
public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
    if(root == null) {
        return new ArrayList<>();
    }
    res = new ArrayList<>();
    ArrayList<Integer> list = new ArrayList<>(); //记录当前路径
    int sum = 0; // 当前路径和
    search(root, target, list, sum); // 查找二叉树所有路径，并将路径和等于target的路径存到res
    Sort(res); // res中的list按长度从小到大排序
    return res;
}

private void search(TreeNode node, int target, ArrayList<Integer> list, int sum) {
    if(node == null) {
        return;
    }
    sum += node.val;
    list.add(node.val);
    if(node.left == null && node.right == null && sum == target) {
        ArrayList<Integer> List = new ArrayList<>(list);
        res.add(List);
    }
    search(node.left, target, list, sum);
    search(node.right, target, list, sum);
    list.remove(list.size() - 1); // 回溯当前叶节点
}

private void Sort(ArrayList<ArrayList<Integer>> res) {
    if (res == null ||res.size() < 2) {
        return;
    }

    for (int i = 0; i < res.size(); i++) {
        int minIndex = i;
        for (int j = i + 1; j < res.size(); j++) {
            if (res.get(i).size() < minIndex) {
                // 更新maxIndex
                minIndex = j;
            }
        }
        // 交换maxIndex与i的list
        ArrayList<Integer> help = res.get(i);
        res.set(i, res.get(minIndex));
        res.set(minIndex, help);
    }
}
```



### 题目7：二叉搜索树与双向链表 

#### 题目描述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 思路

```java
Queue<TreeNode> queue = new LinkedList<>();
public TreeNode Convert(TreeNode pRootOfTree) {
    // base case
    if (pRootOfTree == null)
        return null;
    // 1.先将中序遍历二叉树的所有节点存到队列中
    midPrint(pRootOfTree);

    // 2.改变各个节点的指针域为双向链表
    TreeNode head = queue.poll();
    TreeNode pre = head;
    pre.left = null;
    TreeNode cur = null;
    while (!queue.isEmpty()) {
        cur = queue.poll();
        pre.right = cur;
        cur.left = pre;
        pre = cur;
    }
    pre.right = null;

    return head;
}

public void midPrint(TreeNode root) {
    if (root == null)
        return;
    midPrint(root.left);
    queue.add(root);
    midPrint(root.right);
}
```



### 题目8：二叉树的深度

#### 题目描述

输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

#### 思路

```java
public int TreeDepth(TreeNode root) {
    if(root == null) {
        return 0;
    }
    int ans = 0;
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()) {
        int count = queue.size(); // 当前层的节点数count
        while(count > 0) {
            TreeNode curNode = queue.poll();
            if(curNode.left != null) {
                queue.add(curNode.left);
            }
            if(curNode.right != null) {
                queue.add(curNode.right);
            }
            count--;
        }
        ans++; // 每遍历一层深度+1
    }
    return ans;
}
```



### 题目9：平衡二叉树

#### 题目描述

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树

#### 思路

```java
class returnData {
    boolean isB;
    int h;
    public returnData(boolean isB, int h) {
        this.isB = isB;
        this.h = h;
    }
}

public boolean IsBalanced_Solution(TreeNode root) {
    if(root == null) 
        return true;
    return process(root).isB;
}

private returnData process(TreeNode root) {
    if(root == null)
        return new returnData(true, 0);
    returnData leftData = process(root.left);
    if(leftData.isB == false)
        return new returnData(false, 0);
    returnData rightData = process(root.right);
    if(rightData.isB == false)
        return new returnData(false, 0);
    if(Math.abs(leftData.h - rightData.h) > 1)
        return new returnData(false, 0);
    return new returnData(true, Math.max(leftData.h, rightData.h) + 1);
}
```



### 题目10：二叉树的下一个节点

#### 题目描述

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

#### 思路

```java
public TreeLinkNode GetNext(TreeLinkNode pNode){
    if(pNode == null)
        return null;
    // 情况1：pNode右孩子不为空：pNode的下一个节点是其右子树中最左的节点
    if(pNode.right != null) {
        TreeLinkNode cur = pNode.right;
        while(cur.left != null) {
            cur = cur.left;
        }
        return cur;
    }
    if(pNode.next == null) // 情况2：pNode是右孩子为空的根节点
        return null;
    // 情况3：pNode是其父节点的左孩子：pNode的下一个节点是其父节点
    if(pNode.next.left == pNode) {
        return pNode.next;
    } else if(pNode.next.right == pNode){ // 情况4：pNode是其父节点的右孩子，pNode的下一个节点是其父节点的父节点
        if(pNode.next.next.right == pNode.next) { // 情况5：pNode是中序遍历的最后一个节点（判断pNode的父节点是不是pNode的父节点的父节点的右孩子）
            return null;
        }
        return pNode.next.next;
    }
    return null;
}
```



### 题目11：对成二叉树

#### 题目描述

请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

#### 思路

```java
boolean isSymmetrical(TreeNode root){
    if (root == null)
        return true;
    return judge(root, root);
}
private boolean judge(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null)
        return true;
    if ((root1 == null && root2 != null) || (root1 != null && root2 == null) 
        || (root1.val != root2.val))
        return false;
    return judge(root1.left, root2.right) && judge(root1.right, root2.left);
}
```



### 题目12：序列化二叉树

#### 题目描述

请实现两个函数，分别用来序列化和反序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。

例如，我们可以把一个只有根节点为1的二叉树序列化为"1,"，然后通过自己的函数来解析回这个二叉树

```
示例
	你可以将以下二叉树：
        1
       / \
      2   3
         / \
        4   5
	序列化为 "[1,2,3,null,null,4,5]"
```

#### 思路

```java
// 序列化
String Serialize(TreeNode root) {
    if(root == null)
        return "#_";
    String res = root.val + "_";
    res += Serialize(root.left);
    res += Serialize(root.right);
    return res;
}
// 下面两个函数实现反序列化
TreeNode Deserialize(String str) {
    String[] strs = str.split("_");
    LinkedList<String> queue = new LinkedList<>();
    for (String s : strs) {
        queue.add(s);
    }
    return rebuild(queue);
}
private TreeNode rebuild(LinkedList<String> queue) {
    String value = queue.poll();
    if (value.equals("#")) // 空节点
        return null;
    TreeNode node = new TreeNode(Integer.valueOf(value));
    node.left = rebuild(queue);
    node.right = rebuild(queue);
    return node;
}
```



### 题目13：二叉搜索树的第k大节点

#### 题目描述

给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。

#### 思路

```java
TreeNode KthNode(TreeNode pRoot, int k){
    if(pRoot == null || k == 0) return null;
    ArrayList<TreeNode> list = new ArrayList<>();
    getInOrderList(pRoot, list);
    if(k > list.size()) return null;
    return list.get(k - 1);
}

private void getInOrderList(TreeNode node, ArrayList<TreeNode> list) {
    if(node == null) return;
    getInOrderList(node.left, list);
    list.add(node);
    getInOrderList(node.right, list);
}
```



### 题目14：二叉树的后继结点

#### 题目描述

在二叉树中找一个节点中序遍历的后继结点。

#### 思路

当前节点有右子树，其后继结点就是右子树最左的节点
当前节点没有右子树，其后继结点就是以当前节点为左子树的最后一个节点的父节点

```java
public static Node findSuccessor(Node node) {
    // base case-
    if (node == null) {
        return null;
    }

    if (node.right != null) { // 当前节点有右子树
        return findRightMostLeftNode(node.right);
    } else { // 当前节点没有右子树
        Node parent = node.parent;
        while (parent != null && parent.left != node) {
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
```



### 题目15：二叉树的前驱节点

#### 题目描述

在二叉树中找一个节点中序遍历的前驱结点。

#### 思路

当前节点有左子树，其前驱结点就是左子树最右的节点

当前节点没有左子树，其前驱结点就是以当前节点为右子树的最后一个节点的父节点                      

```java
public static Node findPredecessor(Node node) {
    // base case
    if (node == null) {
        return null;
    }

    if (node.left != null) { // 当前节点有左子树
        return findLeftMostRight(node.left);
    } else { // 当前节点没有左子树
        Node parent = node.parent;
        while (parent != null && parent.right != node) {
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}

// 返回当前节点的左子树最右的节点
private static Node findLeftMostRight(Node node) {
    while (node.right != null) {
        node = node.right;
    }
    return node;
}
```



### 题目16：判断二叉树是不是搜索二叉树

#### 题目描述

判断一棵二叉树是否是搜索二叉树：对于任何一颗子树，左子树比根节点小，右子树比根节点大。

#### 思路

```java
private static long pre = Long.MIN_VALUE;

public static boolean judgeIsSearchBinaryTree(treeNode root) {
    if (root == null) {
        return true;
    }
    boolean left = judgeIsSearchBinaryTree(root.left);
    if (root.val <= pre) {
        return false;
    }
    pre = root.val;
    boolean right = judgeIsSearchBinaryTree(root.right);
    return left && right;
}
```



### 题目17：判断一棵二叉树是否是完全二叉树

#### 题目描述

判断一棵二叉树是否是完全二叉树。

#### 思路

情况1：无左有右，则一定不是完全二叉树，返回false;

 情况2：<1>左右双全，遍历下一个节点；

​			   <2>有左无右，则后面遇到的结点必须都是叶节点才能使完全二叉树，否则false;

​			   <3>无左无右，则后面遇到的结点必须都是叶节点才能使完全二叉树，否则false。

```java
public static boolean judgeIsCompleteBinaryTree(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    TreeNode treeNode = queue.poll();
    while (treeNode != null) {
        queue.add(treeNode.left);
        queue.add(treeNode.right);
        treeNode = queue.poll();
    }
    while (!queue.isEmpty()) {
        treeNode = queue.poll();
        if (treeNode != null) {
            return false;
        }
    }
    return true;
}
```



### 题目18：完全二叉树的节点数

#### 题目描述

完全二叉树的节点数(要求：时间复杂度低于O(N))

#### 思路

满二叉树的高度是L，其节点个数是 2^L - 1

```java
private static int process(treeNode root) {
    if (root == null) {
        return 0;
    }

    int leftDepth = getTreeHeight(root.left); // 左子树高度
    int rightDepth = getTreeHeight(root.right); // 右子树高度
    if (leftDepth == rightDepth) { // 左右子树高度相同 --> 左子树为满二叉树
        // 1(根节点) + (1 << ld)-1(左完全左子树节点数) + 右子树节点数量
        return 1 + (1 << leftDepth) - 1 + process(root.right); 
    } else { // 左右子树高度不同 --> 右子树为满二叉树
        // 1(根节点) + (1 << rd)-1(右完全右子树节点数) + 左子树节点数量
        return 1 + (1 << rightDepth) - 1 + process(root.left); 
    }
}

private static int getTreeHeight(treeNode node) {
    int depth = 0;
    while (node != null) {
        depth++;
        node = node.left;
    }
    return depth;
}
```



### 题目19：二叉搜索树的后序遍历序列

#### 题目描述

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

#### 思路

```java
public boolean VerifySquenceOfBST(int [] sequence) {
    if (sequence == null || sequence.length == 0) {
        return false;
    }
    ArrayList<Integer> list = new ArrayList<>();
    for (int num : sequence) {
        list.add(num);
    }
    return process(list);
}

private boolean process(ArrayList<Integer> list) {
    if (list.size() == 0 || list.size() == 1) { // 左右子树可能不存在
        return true;
    }
    ArrayList<Integer> minList = new ArrayList<>(); // 小于end的序列
    ArrayList<Integer> maxList = new ArrayList<>(); // 大于end的序列
    int end = list.get(list.size() - 1);
    int minIndex = -1, maxIndex = -1; // 第一次小于end的位置、第一次大于end的位置
    for (int i = 0; i < list.size() - 1; i++) { // 根据end划分list为大于和小于两个序列
        if (list.get(i) < end) {
            if (minIndex == -1) {
                minIndex = i;
            }
            minList.add(list.get(i));
        }
        if (list.get(i) > end) {
            if (maxIndex == -1) {
                maxIndex = i;
            }
            maxList.add(list.get(i));
        }
    }
    if (minIndex != -1 && maxIndex != -1) { // 左右两个子树都存在
        if (maxIndex < minIndex) { // 本质上是右子树上的数小
            return false;
        }
        // 本质上是大于序列不连续，即右子树有小于根节点的数
        for (int i = maxIndex; i < list.size() - 1; i++) { 
            if (list.get(i) < end) {
                return false;
            }
        }
    }

    return process(minList) && process(maxList);
}
```



## 栈和队列

### 题目1：用两个栈实现队列

#### 题目描述

用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

#### 思路

```java
Stack<Integer> stack1 = new Stack<Integer>();
Stack<Integer> stack2 = new Stack<Integer>();

public void push(int node) {
    stack1.push(node);
}

public int pop() {
    if(stack2.isEmpty()) { // stack2是空
        while(!stack1.isEmpty()) { // 将stack1中所有元素压入stack2中
            stack2.push(stack1.pop());
        }
    }
    return stack2.pop(); // stack2不为空
}
```



### 题目2：包含min函数的栈

#### 题目描述

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。

#### 思路

```java
Stack<Integer> dataStack = new Stack<>();
Stack<Integer> minStack = new Stack<>();
public void push(int node) {
    dataStack.push(node);
    if(minStack.isEmpty()) {
        minStack.push(dataStack.peek());
    } else {
        if(dataStack.peek() < minStack.peek()) {
            minStack.push(dataStack.peek());
        } else {
            minStack.push(minStack.peek());
        }
    }
}

public void pop() {
    dataStack.pop();
    minStack.pop();
}

public int top() {
    return dataStack.peek();
}

public int min() {
    return minStack.peek();
}
```



### 题目3：栈的压入、弹出序列

#### 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

#### 思路

借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。

```java
public boolean IsPopOrder(int [] pushA,int [] popA) {
    if(pushA.length == 0 || popA.length == 0) {
        return false;
    }
    Stack<Integer> help = new Stack<>();
    int index = 0;
    for(int num : pushA) {
        help.push(num);
        while(!help.isEmpty() && help.peek() == popA[index]) {
            help.pop();
            index++;
        }
    }
    return help.isEmpty();
}
```



### 题目4：滑动窗口的最大值

#### 题目描述

给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。

```
示例：
    输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
    输出: [3,3,5,5,6,7] 
    解释: 

      滑动窗口的位置                最大值
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7
```

#### 思路

```java
public int[] maxSlidingWindow(int[] nums, int k) {
    if(nums == null || k == 0)
        return new int[] {};
    int[] ans = new int[nums.length - k + 1];
    int index = 0; // ans的下标
    // 维护一个从左到右（从头到尾）递减的单调队列，队列存的下标
    LinkedList<Integer> queue = new LinkedList<>();
    for(int i = 0; i < nums.length; i++) {
        // 窗口加数：当且仅当队尾元素对应的值大于入队元素新元素才能入队，否则队尾弹出，直到满足要求
        while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]) {
            queue.pollLast();
        }
        queue.add(i);
        // 窗口减数：队首元素 = i - k时队首元素出队
        if(queue.peekFirst() == i - k) {
            queue.pollFirst();
        }
        // 保存当前窗口最大值：窗口大小满足k时开始储存
        if(i - k >= -1) {
            ans[index++] = nums[queue.peekFirst()];
        }
    }
    return ans;
}
```



### 题目5：丑数

#### 题目描述

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

#### 思路

```java
public int GetUglyNumber(int index) {
    if(index == 0) {
        return 0;
    }
    int[] res = new int[index];
    res[0] = 1;
    int index1 = 0; // 乘2
    int index2 = 0; // 乘3
    int index3 = 0; // 乘5
    for(int i = 1; i < index; i++) {
        res[i] = Math.min(Math.min(res[index1] * 2, res[index2] * 3), 
                          res[index3] * 5);
        if(res[i] == res[index1] * 2) {
            index1++;
        }
        if(res[i] == res[index2] * 3) {
            index2++;
        }
        if(res[i] == res[index3] * 5) {
            index3++;
        }
    }
    return res[index - 1];
}
```



## 堆

### 题目1：数据流中的中位数

#### 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

#### 思路

```java
class myComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2){
        return o2 - o1;
    }
}

PriorityQueue<Integer> minHeap = new PriorityQueue<>(); // 小根堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(new myComparator()); // 大根堆
public void Insert(Integer num) {
    // 数据流个数是偶数个，num进大根堆
    if((minHeap.size() + maxHeap.size()) % 2 == 0) { 
        maxHeap.add(num);
        // 大根堆堆顶元素大于小根堆堆顶元素，堆顶交换
        if(!minHeap.isEmpty() && (maxHeap.peek() > minHeap.peek())) { 
            int help = maxHeap.poll();
            maxHeap.add(minHeap.poll());
            minHeap.add(help);
        }
    } else { // 数据流个数是奇数个，num进小根堆
        minHeap.add(num);
        // 小根堆堆顶元素小于大根堆堆顶元素，堆顶交换
        if(!maxHeap.isEmpty() && (minHeap.peek() < maxHeap.peek())) { 
            int help = minHeap.poll();
            minHeap.add(maxHeap.poll());
            maxHeap.add(help);
        }
    }
}

public Double GetMedian() {
    // 当前数据流一共偶数个数，中位数是大小根堆堆顶元素之和除以2
    if((minHeap.size() + maxHeap.size()) % 2 == 0) { 
        return (((double)minHeap.peek() + (double)maxHeap.peek()) / 2);
    } else { // 当前数据流一共奇数个数，中位数是大根堆堆顶元素
        return (double)maxHeap.peek();
    }
}
```



### 题目2：最小的K个数

#### 题目描述

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

#### 思路

```java
public int[] getLeastNumbers(int[] arr, int k) {
    if(arr == null || k == 0)
        return new int[] {};
    PriorityQueue<Integer> pq = new PriorityQueue<>();
    for(int num : arr) {
        pq.add(num);
    }
    int[] ans = new int[k];
    int index = 0;
    while(index < k) {
        ans[index++] = pq.poll();
    }
    return ans;
}
```



## HashMap

### 题目1：数组中出现次数超过一半的数

#### 题目描述

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

#### 思路

```java
public int MoreThanHalfNum_Solution(int [] array) {
    if(array == null || array.length == 0) {
        return 0;
    }
    if(array.length == 1) {
        return array[0];
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < array.length; i++) {
        if(map.containsKey(array[i])) {
            map.put(array[i], map.get(array[i]) + 1);
            if (map.get(array[i]) > array.length / 2) {
                return array[i];
            }
        } else {
            map.put(array[i], 1);
        }
    }
    return 0;
}
```



### 题目2：第一个只出现一次的字符

#### 题目描述

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

#### 思路

```java
public int FirstNotRepeatingChar(String str) {
    if(str == null || str.length() == 0) {
        return -1;
    }
    char[] arr = str.toCharArray();
    HashMap<Character, Integer> map = new HashMap<>();
    for(int i = 0; i < arr.length; i++) {
        if(map.containsKey(arr[i])) {
            map.put(arr[i], map.get(arr[i]) + 1);
        } else {
            map.put(arr[i], 1);
        }
    }
    for(int i = 0; i < arr.length; i++) {
        if(map.get(arr[i]) == 1) {
            return i;
        }
    }
    return -1;
}
```



### 题目3：字符流中第一个不重复的字符

#### 题目描述

请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。

输出描述:
如果当前字符流没有存在出现一次的字符，返回#字符。

#### 思路

```java
ArrayList<Character> list = new ArrayList<>();
Map<Character, Integer> map = new HashMap<>();
//Insert one char from stringstream
public void Insert(char ch)
{
    list.add(ch);
    if(map.containsKey(ch)) {
        map.put(ch, map.get(ch) + 1);
    } else {
        map.put(ch, 1);
    }
}
//return the first appearence once char in current stringstream
public char FirstAppearingOnce()
{
    for(Character s : list) {
        if(map.get(s) == 1) {
            return s;
        }
    }
    return '#';
}
```



## 打印问题

### 题目1：按之字形顺序打印二叉树

#### 题目描述

请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

#### 思路

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    if (root == null)
        return new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    LinkedList<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    int sum = 1; // 初始化当前层节点的个数
    int flag = 1; // 偶数就从右往左打印
    while (!queue.isEmpty()) {
        List<Integer> list = new ArrayList<>();
        int temp = 0; // 下一层节点的个数
        while (sum > 0) {
            TreeNode curNode = queue.poll();
            list.add(curNode.val);
            if (curNode.left != null) {
                queue.add(curNode.left);
                temp++;
            }
            if (curNode.right != null) {
                queue.add(curNode.right);
                temp++;
            }
            sum--;
        }
        if (flag % 2 == 0) { // 偶数层从右往左存：反置list
            for (int i = 0, j = list.size() - 1; i < j; i++, j--) {
                int res = list.get(i);
                list.set(i, list.get(j));
                list.set(j, res);
            }
        }
        flag++;
        ans.add(list);
        sum = temp; // 更新当前层的节点数
    }
    return ans;
}
```



### 题目2：顺时针打印矩阵

#### 题目描述

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

#### 思路

```java
public static ArrayList<Integer> printMatrix(int[][] matrix) {
    if (matrix == null) {
        return null;
    }

    int Lx = 0, Ly = 0; //  左上角x,y
    int Rx = matrix.length - 1, Ry = matrix[0].length - 1; // 右下角x,y

    return printProcess(matrix, Lx, Ly, Rx, Ry);
}

private static ArrayList<Integer> printProcess(int[][] matrix, int Lx, 
                                               int Ly, int Rx, int Ry) {
    ArrayList<Integer> res = new ArrayList<>();
    while (Lx <= Rx && Ly <= Ry) {
        if (Lx == Rx) {
            while (Ly <= Ry) {
                res.add(matrix[Lx][Ly++]);
            }
        }
        if (Ly == Ry) {
            while (Lx <= Rx) {
                res.add(matrix[Lx++][Ly]);
            }
        }
        int curX = Lx, curY = Ly;
        while (curY < Ry) {
            res.add(matrix[Lx][curY++]);
        }
        while (curX < Rx) {
            res.add(matrix[curX++][Ry]);
        }
        while (curY > Ly) {
            res.add(matrix[Rx][curY--]);
        }
        while (curX > Lx) {
            res.add(matrix[curX--][Ly]);
        }
        Lx++;
        Ly++;
        Rx--;
        Ry--;
    }
    return res;
}
```



## 图

### 题目1：岛屿数量

#### 题目描述

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

#### 思路

```java
public int numIslands(char[][] grid) {
    if(grid == null)
        return 0;
    int ans = 0;
    for(int i = 0; i < grid.length; i++) {
        for(int j = 0; j < grid[0].length; j++) {
            if(grid[i][j] == '1') {
                ganRan(grid, i, j);
                ans++; // 遇到一个1并将其上下左右全部感染后，岛屿数量加1
            }
        }
    }
    return ans;
}
private void ganRan(char[][] grid, int x, int y) {
    // 越界 || grid[x][y] != '1'
    if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length
       || grid[x][y] != '1')
        return;
    grid[x][y] = '2'; // 当前位置感染为2
    ganRan(grid, x + 1, y);
    ganRan(grid, x - 1, y);
    ganRan(grid, x, y + 1);
    ganRan(grid, x, y - 1);
}
```



### 题目2：矩阵中的路径（BFS）

#### 题目描述

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","b","c","e"],
["s","f","c","s"],
["a","d","e","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

#### 思路

```java
public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
    // 一维数组转二维数组
    char[][] board = new char[rows][cols];
    int y = 0;
    int x = 0;
    for (char c : matrix) {
        if (y >= cols) {
            y = 0;
            x++;
        }
        board[x][y] = c;
        y++;
    }

    if (board == null || str == null)
        return false;
    int height = board.length;
    int width = board[0].length;
    boolean[][] flag = new boolean[height][width]; // 标记是否走过（false：没走过）
    // 遍历二维数组，判断以每个位置为起点是否存在匹配的路径
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
			// 判断以board[i][j]为起点是否存在匹配的路径
            if (judge(board, flag, i, j, 0, str)) {
                return true;
            }
        }
    }
    return false;
}

private boolean judge(char[][] board, boolean[][] flag,
                      int i, int j, int k, char[] aim) { // k是aim数组的索引
    // 越界 || 当前位置不匹配 || 当前位置已经走过
    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length
        || board[i][j] != aim[k] || flag[i][j])
        return false;
    flag[i][j] = true; // 标记当前位置已经走过
    // 走到此处说明board[i][j]与aim[k]是匹配的
    if (k == aim.length - 1) // 最后一个字符匹配成功 -> 递归终止 -> 找到路径
        return true;
    // 当前位置匹配成功后判断当前位置的上下左右是否存在与aim[k + 1]位置匹配，如果有就继续递归寻找下	  // 一个当前位置的上下左右是否存在与aim[k + 1]位置匹配...
    if (judge(board, flag, i + 1, j, k + 1, aim)
        || judge(board, flag, i - 1, j, k + 1, aim)
        || judge(board, flag, i, j + 1, k + 1, aim)
        || judge(board, flag, i, j - 1, k + 1, aim))
        return true;
    flag[i][j] = false; // 上面if匹配失败，将走过的位置回溯为没走过
    return false; // 以当前i，j为起点匹配失败。判断board的下一个位置为起点是否可以匹配成功
}
```



### 题目3：机器人的运动范围（DFS）

#### 题目描述

地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

#### 思路

```java
int ans = 0;
public int movingCount(int threshold, int rows, int cols){
    boolean[][] m = new boolean[rows][cols];
    solve(threshold, rows, cols, m, 0, 0);
    return ans;
}
private void solve(int threshold, int rows, int cols, boolean[][] m, int x, int y) {
    // 越界 || 当前位置走过了 || x,y坐标数位之和大于threshold
    if(x < 0 || x >= rows || y < 0 || y >= cols
       || m[x][y] || calcu(x, y) > threshold)
        return;
    m[x][y] = true; // 当前位置可以走
    ans++;
    solve(threshold, rows, cols, m, x + 1, y);
    solve(threshold, rows, cols, m, x - 1, y);
    solve(threshold, rows, cols, m, x, y + 1);
    solve(threshold, rows, cols, m, x, y - 1);
}
// 计算num1、num2的数位之和
private int calcu(int num1, int num2) {
    int res = 0;
    while(num1 != 0) {
        res += num1 % 10;
        num1 /= 10;
    }
    while(num2 != 0) {
        res += num2 % 10;
        num2 /= 10;
    }
    return res;
}
```



## 字符串

### 题目1：表示数值的字符串

#### 题目描述

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

#### 思路

```java
public boolean isNumeric(char[] str) {
    // 标记符号、小数点、e是否出现过
    boolean sign = false, decimal = false, hasE = false;
    for (int i = 0; i < str.length; i++) {
        if (str[i] == 'e' || str[i] == 'E') {
            if (i == str.length - 1) return false; // e后面一定要接数字
            if (hasE) return false;  // 不能同时存在两个e
            hasE = true;
        } else if (str[i] == '+' || str[i] == '-') {
            // 第二次出现+-符号，则必须紧接在e之后
            if (sign && str[i-1] != 'e' && str[i-1] != 'E') return false;
            // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后
            if (!sign && i > 0 && str[i-1] != 'e' && str[i-1] != 'E') return false;
            sign = true;
        } else if (str[i] == '.') {
            // e后面不能接小数点，小数点不能出现两次
            if (hasE || decimal) return false;
            decimal = true;
        } else if (str[i] < '0' || str[i] > '9') // 不合法字符
            return false;
    }
    return true;
}
```



### 题目2：正则表达式匹配

#### 题目描述

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

#### 思路

```java

```



### 题目3：把字符串转换成整数

#### 题目描述

将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

#### 输入描述

输入一个字符串,包括数字字母符号,可以为空。

#### 输出描述

如果是合法的数值表达则返回该数字，否则返回0。

#### 示例

```
输入
	+2147483647
	1a33
输出
	2147483647
	0
```

#### 思路

```java
// 牛客
public int StrToInt1(String str) {
    if (str == null || str.length() == 0)
        return 0;
    char[] array = str.toCharArray();
    int len = array.length;
    int ans = 0;
    if (array[0] == '+') {
        for (int i = 1; i < array.length; i++) {
            if ((array[i] >= 'a' && array[i] <= 'z') ||
                (array[i] >= 'A' && array[i] <= 'Z')) {
                return 0;
            }
            ans += Math.pow(10, len - i - 1) *
                Integer.parseInt(String.valueOf(array[i]));
        }
    } else if (array[0] == '-') {
        for (int i = 1; i < array.length; i++) {
            if ((array[i] >= 'a' && array[i] <= 'z') ||
                (array[i] >= 'A' && array[i] <= 'Z')) {
                return 0;
            }
            ans += Math.pow(10, len - i - 1) *
                Integer.parseInt(String.valueOf(array[i]));
        }
        ans = -ans;
    } else {
        for (int i = 0; i < array.length; i++) {
            if ((array[i] >= 'a' && array[i] <= 'z') ||
                (array[i] >= 'A' && array[i] <= 'Z')) {
                return 0;
            }
            ans += Math.pow(10, len - i - 1) *
                Integer.parseInt(String.valueOf(array[i]));
        }
    }
    return ans;
}
```



### 题目4：扑克牌顺子

#### 题目描述

LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

#### 思路

```java
public boolean isContinuous(int [] nums) {
    if(nums == null || nums.length == 0)
        return false;
    Arrays.sort(nums);
    // 统计nums中0的个数并删除0，nums中只留下非0的数字
    int zeroNums = 0;
    int[] noZeroNums = new int[nums.length];
    int index = 0;
    for(int num : nums) {
        if(num == 0) {
            zeroNums++;
        } else {
            if(index < nums.length) {
                noZeroNums[index++] = num;
            }
        }
    }
    // 统计nums中空缺位置的个数
    int spaceNums = 0;
    int pre = noZeroNums[0];
    for(int i = 1; i < noZeroNums.length - zeroNums; i++) {
        if(noZeroNums[i] == pre) {
            return false;
        }
        if(noZeroNums[i] - pre > 1) {
            spaceNums += noZeroNums[i] - pre - 1;
        }
        pre = noZeroNums[i];
    }
    return zeroNums >= spaceNums || spaceNums == 0;
}
```



### 题目5：翻转单词序列

#### 题目描述

牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？

#### 思路

```java
public String ReverseSentence(String s) {
    if(s == null || s.length() == 0 || s.trim().length()==0)
        return s;
    String[] strings = s.split("\\s+");
    StringBuilder res = new StringBuilder();
    for (int i = strings.length - 1; i >= 0; i--) {
        res.append(strings[i]);
        if (i > 0) {
            res.append(" ");
        }
    }
    return res.toString().trim();
}
```



### 题目6：左旋转字符串

#### 题目描述

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

#### 思路

```java
public String LeftRotateString(String str, int n) {
    if (str == null || str.length() == 0)
        return "";
    char[] arr = str.toCharArray();
    StringBuilder sb1 = new StringBuilder();
    StringBuilder sb2 = new StringBuilder();
    for (int i = 0; i < arr.length; i++) {
        if (i < n) {
            sb1.append(arr[i]);
        } else {
            sb2.append(arr[i]);
        }
    }
    sb2.append(sb1);
    return sb2.toString();
}
```



### 题目7：字符串的全排列

#### 题目描述

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

#### 输入描述

输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

#### 思路

```java
public ArrayList<String> Permutation(String str) {
    if (str == null || str.length() == 0) {
        return new ArrayList<String>();
    }
    char[] array = str.toCharArray();
    ArrayList<String> res = new ArrayList<>(); // 返回结果
    solve(array, 0, res, array.length); // 得到字符串全排列
    res = new ArrayList<>(new HashSet<>(res)); // 去重
    Collections.sort(res); // 按字典序排序
    return res;
}

// 得到字符串的全排列
private void solve(char[] array, int index, ArrayList<String> res, int length) {
    if (index == length) { // 当前填充位置为数组中最后一位
        String s = changeToString(array); // 将字符数组转成字符串
        res.add(s); // 将当前字符串排列方式存到res
    } else {
        for (int i = index; i < length; i++) {
            swap(array, index, i); // 交换得到index位置可能出现的字符所能产生的组合
            solve(array, index + 1, res, length);
            swap(array, index, i); // 交换一次回溯一次，否则就不是index位置的全排列
        }
    }
}

private void swap(char[] array, int index, int i) {
    char help = array[index];
    array[index] = array[i];
    array[i] = help;
}

private String changeToString(char[] array) {
    StringBuilder sb = new StringBuilder();
    for (char str : array) {
        sb.append(str);
    }
    return sb.toString();
}
```



### 题目8：替换空格

#### 题目描述

请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 思路

```java
public static String replaceSpace(StringBuffer str) {
    if (str == null || str.length() == 0) {
        return "";
    }

    String STR = str.toString();
    char[] strArray = STR.toCharArray();
    //            int spaceNum = 0; // 空格总数
    //            for(int i = 0; i < strArray.length; i ++) {
    //                if(strArray[i] == ' ') {
    //                    spaceNum++;
    //                }
    //            }
    //char[] newArray = new char[STR.length() + 3 * spaceNum - spaceNum];
    StringBuilder res = new StringBuilder();
    int index = 0;
    for (int i = 0; i < strArray.length; i++) {
        if (strArray[i] != ' ') {
            //newArray[index++]= strArray[i];
            res.append(strArray[i]);
        } else {
            res.append("%20");
            //newArray[index++] = '%';
            //newArray[index++] = '2';
            //newArray[index++] = '0';
        }
    }
    return res.toString();
}
```



## 数组类题目

### 题目1：构建乘积数组

#### 题目描述

给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）
对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。

#### 思路

```java
public int[] multiply(int[] A) {
    if(A == null || A.length == 0) {
        return new int[]{};
    }
    int[] B = new int[A.length];
    B[0] = 1; // B[0]
    for(int i = 1; i < A.length; i++) {
        B[0] *= A[i];
    }
    B[B.length - 1] = 1; // B[N - 1]
    for(int i = 0; i < A.length - 1; i++) {
        B[B.length - 1] *= A[i];
    }
    for(int i = 1; i < B.length - 1; i++) {
        B[i] = left(A, i) * right(A, i);
    }
    return B;
}
// 计算0 ~ index-1的连乘积
private int left(int[] A, int index) {
    int ans = 1;
    for(int i = 0; i < index; i++) {
        ans *= A[i];
    }
    return ans;
}
// 计算index+1 ~ A.length-1的连乘积
private int right(int[] A, int index) {
    int ans = 1;
    for(int i = index + 1; i < A.length; i++) {
        ans *= A[i];
    }
    return ans;
}
```



### 题目2：把数组排成最小的数字

#### 题目描述

输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

#### 思路

```java
// 方法1：找出所有拼接的形式 -> 从小到大排序 -> 返回第一个
public String PrintMinNumber1(int[] numbers) {
    if (numbers == null || numbers.length == 0) {
        return "";
    }
    if (numbers.length == 1) {
        return changeToString(numbers);
    }
    ArrayList<String> list = new ArrayList<>();
    int len = numbers.length;
    solve(numbers, 0, list, len);
    list = new ArrayList<String>(new HashSet<String>(list));
    Collections.sort(list);
    return list.get(0);
}

// 找到所有组合形式
private void solve(int[] nums, int index, ArrayList<String> list, int len) {
    if (index == len) {
        String s = changeToString(nums);
        list.add(s);
    } else {
        for (int i = index; i < len; i++) {
            swap(nums, index, i);
            solve(nums, index + 1, list, len);
            swap(nums, index, i);
        }
    }
}

// 数组转字符串
private String changeToString(int[] nums) {
    StringBuilder sb = new StringBuilder();
    for (int num : nums) {
        sb.append(num);
    }
    return sb.toString();
}

private void swap(int[] nums, int index, int i) {
    int help = nums[index];
    nums[index] = nums[i];
    nums[i] = help;
}


// 方法2：自定义比较器
public String PrintMinNumber2(int[] nums) {
    if (nums == null || nums.length == 0) {
        return "";
    }
    ArrayList<String> list = new ArrayList<>();
    for (int num : nums) {
        list.add("" + num);
    }
    Collections.sort(list, new myComparator());
    StringBuilder res = new StringBuilder();
    for (int i = 0; i < list.size(); i++) {
        res.append(list.get(i));
    }
    return res.toString();
}

public class myComparator implements Comparator<String> {
    @Override
    public int compare(String s1, String s2) {
        return (s1 + s2).compareTo(s2 + s1);
    }
}
```



### 题目3：连续子数组的最大和

#### 题目描述

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

#### 思路

```java
public int FindGreatestSumOfSubArray(int[] array) {
    if(array == null || array.length == 0) {
        return 0;
    }
    int max = Integer.MIN_VALUE;
    int curSum = 0;
    for(int i = 0; i < array.length; i++) {
        curSum += array[i];
        max = Math.max(max, curSum);
        curSum = curSum < 0 ? 0 : curSum;
    }
    return max;
}
```



### 题目4：调整数组顺序使奇数位于偶数前面

#### 题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

#### 思路

```java
// 使用辅助数组划分奇偶，再赋值回原数组：O(3N)
public void reOrderArray1(int[] array) {
    if (array == null || array.length == 0) {
        return;
    }
    int[] res = new int[array.length];
    int index = 0;
    for (int cur : array) {
        if (cur % 2 == 1) { // 奇数
            res[index++] = cur;
        }
    }
    for (int cur : array) {
        if (cur % 2 == 0) { // 偶数
            res[index++] = cur;
        }
    }
    int i = 0;
    for (int cur : res) { // 存回原数组
        array[i++] = cur;
    }
}
```



### 题目5：最小的K个数

#### 题目描述

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

#### 思路

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
    if(input == null || input.length == 0 || k == 0 || k > input.length) {
        return new ArrayList<Integer>();
    }
    ArrayList<Integer> res = new ArrayList<>();
    // Arrays.sort(input);
    // 选择排序
    for (int i = 0; i < input.length; i++) {
        int minIndex = i;
        for (int j = i + 1; j < input.length; j++) {
            if (input[j] < input[minIndex]) {
                minIndex = j;
            }
        }
        int help = input[minIndex];
        input[minIndex] = input[i];
        input[i] = help;
    }
    for(int i = 0; i < k; i++) {
        res.add(input[i]);
    }
    return res;
}
```



## 数学类问题

#### 题目1：整数中1出现的次数

##### 题目描述

求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

##### 思路

```java
// 暴力法
public int NumberOf1Between1AndN_Solution1(int n) {
    if (n == 0) {
        return 0;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        int curNum = i;
        while (curNum != 0) {
            if (curNum % 10 == 1) {
                ans++;
            }
            curNum = curNum / 10;
        }
    }
    return ans;
}

// 分段：首位 + 其他位
public int NumberOf1Between1AndN_Solution2(int n) {
    if (n == 0) {
        return 0;
    }

    int ans = 0;

    String str = "" + n; // 将n转换为字符串
    int len = str.length(); // n的位数
    if (len == 1) {
        return 1;
    }
    int res = (int) Math.pow(10, len - 1); // 首位的幂级
    int firstBit = n / res; // 首位上的数
    //int firstBit = str.charAt(0) - '0';
    int otherBit = n % res; // 除了首位，其他位组成的数
    ans = firstBit == 1 ? (otherBit + 1) : res; // 只看首位出现1的个数
    // 除了首位，其他位组成的数1出现的次数:
    // firstBit * 剩下的N-1个位置都可能是1 * 剩下的N-2个位置各有10种选择
    ans += firstBit * (len - 1) * Math.pow(10, len - 1 - 1); 
    return ans + NumberOf1Between1AndN_Solution2(otherBit);
}
```



#### 题目2：二进制中1的个数

##### 题目描述

输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。

##### 思路

```java
// 方法1：temp左移逐个判断n的每一位是否位1
// 缺点：对于每一个数都需要将temp左移32次
public int NumberOfOne1(int n) {
    int sum = 0; // 记录1的个数
    int temp = 1; // 用temp判断n的每一位是否为1
    // int型变量为32位。temp左移32次之后，temp就会变为0。此时说明n遍历结束了
    while (temp != 0) { 
        sum = (n & temp) != 0 ? sum + 1 : sum;
        temp = temp << 1;
    }
    return sum;
}

// 方法2：n & (n -1)即消除n最右边的1
public int NumberOfOne2(int n) {
    int sum = 0; // 记录1的个数
    while (n != 0) { // 说明n中至少有一个1
        sum++;
        n = n & (n - 1); // 利用n - 1消除n最右边的1
    }
    return sum;
}
```



## 具体算法类题目

### 1.斐波那契数列

#### 题目1：斐波那契数列

##### 题目描述

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。n<=39

##### 思路

```java
public int Fibonacci(int n) {
    int preNum = 1;
    int prePreNum = 0;
    if (n == 0) 
        return 0;
    if (n == 1)
        return 1;
    int res = 0;
    for (int i = 2; i <= n; i++) {
        res = preNum + prePreNum;
        prePreNum = preNum;
        preNum = res;
    }
    return res;
}
```



#### 题目2：青蛙跳台阶

##### 题目描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

##### 思路

```java
public int JumpFloor(int target) {
    int preNum = 2;
    int prePreNum = 1; // 没有0级的台阶
    if(target <= 2) {
        return target;
    }
    int res = 0;
    for(int i = 3; i <= target; i++) {
        res = preNum + prePreNum;
        prePreNum = preNum;
        preNum = res;
    }
    return res;
}
```



#### 题目3：矩形覆盖

##### 题目描述

我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

##### 思路

```java
public int RectCover(int target) {
    if (target < 2)
        return target;
    int[] dp = new int[target + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < target + 1; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[target];
}
```



### 2. **搜索算法** 

#### 题目1：二维数组的查找

##### 题目描述

在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

##### 思路

```java
public boolean Find(int target, int [][] array) {
    int startX = 0;
    int startY = array[0].length - 1;
    while(startX < array.length && startY >= 0) {
        if(array[startX][startY] < target) {
            startX = startX + 1;
        } else if (array[startX][startY] > target) {
            startY = startY - 1;
        } else {
            return true;
        }
    }
    return false;
}
```



#### 题目2：旋转数组的最小数字(二分查找)

##### 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

##### 思路

```java
public int minNumberInRotateArray(int [] array) {
    if(array == null || array.length == 0) {
        return 0;
    }
    Arrays.sort(array);
    return array[0];
}
```



### 3.全排列

#### 题目1：字符串的排列

##### 题目描述

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

##### 思路

```java
public ArrayList<String> Permutation(String str) {
    if (str == null || str.length() == 0) {
        return new ArrayList<String>();
    }
    char[] array =  str.toCharArray();
    ArrayList<String> res = new ArrayList<>();
    solve(array, 0, res, array.length); // 得到字符串全排列
    res = new ArrayList<>(new HashSet<>(res)); // 去重
    Collections.sort(res); // 按字典序排序
    return res;
}

private void solve(char[] array, int index, ArrayList<String> res, int length) {
    if (index == length) { // 当前填充位置为数组中最后一位
        String s = changeToString(array); // 将字符数组转成字符串
        res.add(s); // 将当前字符串排列方式存到res
    } else {
        for (int i = index; i < length; i++) {
            swap(array, index, i); // 交换得到index位置可能出现的字符所能产生的组合
            solve(array, index + 1, res, length);
            swap(array, index, i); // 交换一次回溯一次，否则就不是index位置的全排列
        }
    }
}

private void swap(char[] array, int index, int i) {
    char help = array[index];
    array[index] = array[i];
    array[i] = help;
}

private String changeToString(char[] array) {
    StringBuilder sb = new StringBuilder();
    for (char str : array) {
        sb.append(str);
    }
    return sb.toString();
}
```



### 4.动态规划

#### 题目1：连续子数组的最大和

##### 题目描述

HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

##### 思路

```java
public int FindGreatestSumOfSubArray(int[] array) {
    if(array == null || array.length == 0) {
        return 0;
    }
    int max = Integer.MIN_VALUE;
    int curSum = 0;
    for(int i = 0; i < array.length; i++) {
        curSum += array[i];
        max = Math.max(max, curSum);
        curSum = curSum < 0 ? 0 : curSum;
    }
    return max;
}
```



### 5.贪心

#### 题目1：剪绳子

##### 题目描述

给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

##### 输入描述

输入一个数n，意义见题面。（2 <= n <= 60）

##### 输出描述

输出答案。

##### 示例

```
输入
	8
输出
	18
```

##### 思路

```java
public int cutRope(int target) {
    // n<=3的情况，m>1必须要分段
    // 例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,
    if(target==2)
        return 1;
    if(target==3)
        return 2;
    int[] dp = new int[target+1];
    /*
      下面3行是n>=4的情况，跟n<=3不同，4可以分很多段，比如分成1、3，
      这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。
     */
    dp[1]=1;
    dp[2]=2;
    dp[3]=3;
    int res=0;//记录最大的
    for (int i = 4; i <= target; i++) {
        for (int j = 1; j <=i/2 ; j++) {
            res=Math.max(res,dp[j]*dp[i-j]);
        }
        dp[i]=res;
    }
    return dp[target];
}
```

#### 题目2：变态跳台阶

##### 题目描述

一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

##### 思路

```java
public int JumpFloorII(int target) {
    return (int)Math.pow(2, target - 1);
}
```



### 6.双指针

#### 题目1：和为S的两个数字

##### 题目描述

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

##### 输出描述

对应每个测试案例，输出两个数，小的先输出。

##### 思路

```java
public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
    if(array == null || array.length == 0)
        return new ArrayList<Integer>();
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    for(int i = 0; i < array.length; i++) {
        ArrayList<Integer> list = new ArrayList<>();
        for(int j = i; j < array.length; j++) {
            if(array[i] + array[j] == sum) {
                list.add(array[i]);
                list.add(array[j]);
                res.add(list);
            }
        }
    }

    if (res.size() == 0) {
        return new ArrayList<>();
    }

    int min = res.get(0).get(0) * res.get(0).get(1);
    int minIndex = 0;
    for(int i = 1; i < res.size(); i++) {
        if(res.get(i).get(0) * res.get(i).get(1) < min) {
            minIndex = i;
        }
    }
    return res.get(minIndex);
}
```



#### 题目2：和为S的连续正整数序列

##### 题目描述

小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

##### 思路

```java
// 方法1：暴力穷举
public ArrayList<ArrayList<Integer>> FindContinuousSequence1(int sum) {
    if (sum == 0)
        return new ArrayList<>();
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    for (int start = 1; start <= sum / 2 + 1; start++) {
        for (int end = start + 1; end <= sum / 2 + 1; end++) {
            int curSum = 0;
            for (int i = start; i <= end; i++) {
                curSum += i;
            }
            if (curSum == sum) {
                ArrayList<Integer> list = new ArrayList<>();
                for (int i = start; i <= end; i++) {
                    list.add(i);
                }
                res.add(list);
            }
        }
    }
    return res;
}

// 方法2：双指针
public ArrayList<ArrayList<Integer>> FindContinuousSequence2(int target) {
    if (target < 2)
        return new ArrayList<>();
    int p1 = 1, p2 = 2;
    ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
    while (p1 < p2) {
        if (sumP1ToP2(p1, p2) == target) {
            ArrayList<Integer> res = new ArrayList<>();
            int start = p1;
            while (start <= p2) {
                res.add(start);
                start++;
            }
            ans.add(res);
            p1++;
        } else if (sumP1ToP2(p1, p2) < target) {
            p2++;
        } else {
            p1++;
        }
    }
    return ans;
}

private int sumP1ToP2(int p1, int p2) {
    return (p1 + p2) * (p2 - p1 + 1) / 2;
}
```



#### 题目3：数组中的逆序对

##### 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

##### 输入描述

题目保证输入的数组中没有的相同的数字

数据范围：

​	对于%50的数据,size<=10^4

​	对于%75的数据,size<=10^5

​	对于%100的数据,size<=2*10^5

##### 示例

```
输入
	1,2,3,4,5,6,7,0
输出
	7
```

##### 思路

```java
public int InversePairs(int[] array) {
    if (array == null || array.length == 0) {
        return 0;
    }
    return (int) (part(array, 0, array.length - 1) % 1000000007); // 划分数组为两部分
}

private long part(int[] array, int L, int R) {
    if (L == R) {
        return 0;
    }
    int mid = L + (R - L) / 2;
    return part(array, L, mid) + part(array, mid + 1, R) + merge(array, L, mid, R);
}

private long merge(int[] array, int L, int mid, int R) {
    int p1 = L;
    int p2 = mid + 1;
    int[] help = new int[R - L + 1];
    int index = 0;
    long ans = 0;
    while (p1 <= mid && p2 <= R) {
        ans += array[p1] > array[p2] ? (mid - p1 + 1) : 0;
        help[index++] = array[p1] < array[p2] ? array[p1++] : array[p2++];
    }
    while (p1 <= mid) {
        help[index++] = array[p1++];
    }
    while (p2 <= R) {
        help[index++] = array[p2++];
    }
    index = 0;
    for (int i = 0; i < help.length; i++) {
        array[L + i] = help[i];
    }
    return ans;
}
```

