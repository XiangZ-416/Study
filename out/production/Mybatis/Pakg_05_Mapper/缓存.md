# 1.一级缓存
    a. 每个sqlSession都有一个独立的一级缓存（HashMap实现）
    b. sqlSession执行增、删、改后的commit()操作之后就会清空sqlSession中一级缓存的数据
    c. 清空一级缓存的目的：保证以及缓存存储的时最新的数据，避免脏读
    d. Mybatis默认支持一级缓存
    
# 2.二级缓存
    a. 每个mapper标签共享一块二级缓存区域（HashMap实现、二级缓存可以不是内存）
    b. 只有一个sqlSession执行close之后才对另一个sqlSession开启二级缓存
    c. 当一个sqlSession执行commit()操作后，该sqlSession所在的mapper标签对应的二级缓存将被清空
    d. Mybatis默认支持二级缓存，可以通过flushCache="false"关闭二级缓存
    
# 3.应用场景

## 3.1 一级缓存应用场景
    mybatis默认支持一级缓存，避免脏读。

## 3.2 二级缓存应用场景
    对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。
    实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。
    对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。
	实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。

## 3.3 二级缓存的局限性
    mybatis二级缓存对细粒度的数据级别的缓存实现不好。
    细粒度数据：改哪个商品就只变这个商品的价格。
    
    比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户 每次都能查询最新 的商品信息，
    此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将
    所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。


    