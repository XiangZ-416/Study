## 一、装饰模式
    在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
    在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则，和里氏替换原则。
***
## 二、设计原则
    要使用装饰者模式，需要满足以下设计原则：
    1、多用组合，少用继承
    2、开放-关闭原则：类应该对拓展开放，对修改关闭
***
## 三、抽象构件角色
    1) 抽象构件角色（Component）：是基类。通常是一个抽象类或者一个接口，定义了属性或者方法，方法的实现可以由子类实现或者自己实现。通常不会直接使用该类，而
       是通过继承该类来实现特定的功能，它约束了整个继承树的行为。比如说，如果Component代表人，即使通过装饰也不会使人变成别的动物。 
    2) 被装饰者角色(Concrete Component)：是Component的子类，实现了相应的方法，它充当了“被装饰者”的角色。 
    3) 装饰者角色(Decorator)：也是Component的子类，它是装饰者共同实现的抽象类（也可以是接口）。比如说，Decorator代表衣服这一类装饰者，那么它的子类应该是T恤、裙子这样的具体的装饰者。
    4) 具体装饰角色(Concrete Decorator)：是Decorator的子类，是具体的装饰者，由于它同时也是Component的子类，因此它能方便地拓展Component的状态（比如添加新的方法）。每个装饰者都应
       该有一个实例变量用以保存某个Component的引用，这也是利用了组合的特性。在持有Component的引用后，由于其自身也是Component的子类，那么，相当于ConcreteDecorator包裹了Component，
       不但有Component的特性，同时自身也可以有别的特性，也就是所谓的装饰。
***
## 四、案例
    你有一家服装店，卖各式各样的衣服，现在需要用一个系统来记录客户所要购买的衣服的总价，以便方便地结算。那么在这个例子里面，我们可以用装饰者模式，把客户当做被装饰者，衣服是装饰者，这
    很直观形象吧，接着我们来一步步实现需求。
***
## 五、案例类图
   ![decorativeMode.png](imgs/Type_03_decorativeMode.png)
***
## 六、案例总结
    Teenager、Shirt都是继承自Person基类，但是具体实现不同。
    Teenager是Person的直接子类，表示了被装饰者；
    Shirt是装饰者，保存了Person的引用，实现了cost()方法，并且在cost()方法内部，不但实现了自己的逻辑，同时也调用了Person引用的cost()方法，即获取了被装饰者的信息，这是装饰者的一个特点，保存引用的目的就是为了获取被装饰者的状态信息，以便将自身的特性加以组合。
***
## 七、装饰者模式总结
    通过上述的例子，我们可以总结一下装饰者模式的特点：
    （1）装饰者和被装饰者有相同的接口（或有相同的父类）。
    （2）装饰者保存了一个被装饰者的引用。
    （3）装饰者接受所有客户端的请求，并且这些请求最终都会返回给被装饰者（参见韦恩图）。
    （4）在运行时动态地为对象添加属性，不必改变对象的结构。
***
## 八、优缺点
    优点：就是其拓展性十分良好，通过使用不同的装饰类来使得对象具有多种多样的属性，灵活性比直接继承好。
    缺点，那就是会出现很多小类，即装饰类，使程序变得复杂。
***
## 九、应用
    学习了装饰者模式用法、特点以及优缺点后，我们再来看看装饰者模式在实际开发过程的应用。装饰者模式在Java中经常出现的地方就是JavaIO。提到JavaIO，脑海中就冒出了大量的类：InputStream、FileInputStream、BufferedInputStream……等，真是头都大了，其实，这里面大部分都是装饰类，只要弄清楚这一点就容易理解了。
    我们来看看JavaIO是怎样使用装饰者模式的。
    从字符流来分析，我们知道，有两个基类，分别是InputStream和OutputStream，它们也就是我们上面所述的Component基类。接着，它有如下子类：FileInputStream、StringBufferInputStream等，它们就代表了上面所述的ConcreteComponent，即装饰对象。此外，InputStream还有FilterInputStream这个子类，它就是一个抽
    象装饰者，即Decorator，那么它的子类：BufferedInputStream、DataInputStream等就是具体的装饰者了。那么，从装饰者模式的角度来看JavaIO，是不是更加容易理解了呢？